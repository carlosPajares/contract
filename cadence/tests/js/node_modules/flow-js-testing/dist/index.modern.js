import{flowConfig as e}from"@onflow/fcl-config";import{config as n}from"@onflow/config";import a from"fs";import t from"path";import*as r from"@onflow/types";import*as s from"@onflow/fcl";import{mapValuesToCode as o,getEnvironment as c,reportMissingImports as i,replaceImportAddresses as l,reportMissing as d}from"flow-cadut";import{ec as g}from"elliptic";import{SHA3 as u}from"sha3";import*as p from"rlp";const m=(e,n,a)=>{if("string"==typeof n)return m(e,n.split("/"),a);if(!n.length)return e;try{const[t,...r]=n;return m(e[t],r,a)}catch(e){return a}},f=(a,t,r,s)=>{let o=m(e(),r,s);o||(o=s),n().put(a,o)},w=async e=>n().get(e),h=async(e,a={})=>{const{port:t=8080}=a,{pkey:r="48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902"}=a;f("PRIVATE_KEY",process,"accounts/emulator-account/key",r),f("SERVICE_ADDRESS",process,"accounts/emulator-account/address","f8d6e0586b0a20c7"),n().put("accessNode.api",`http://localhost:${t}`),f("BASE_PATH",process,"resolve/basePath",e)};function M(){return(M=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}const A=e=>null==e?null:e.replace(/^0x/,""),y=e=>null==e?null:"0x"+A(e),b=new g("p256"),S=(e,n)=>{const a=b.keyFromPrivate(Buffer.from(e,"hex")).sign((e=>{const n=new u(256);return n.update(Buffer.from(e,"hex")),n.digest()})(n)),t=a.r.toArrayLike(Buffer,"be",32),r=a.s.toArrayLike(Buffer,"be",32);return Buffer.concat([t,r]).toString("hex")},T=(e,a=0)=>async(t={})=>{const r=await n().get("SERVICE_ADDRESS"),o=await n().get("PRIVATE_KEY");return M({},t,{tempId:`${e=A(e||r)}-${a}`,addr:s.sansPrefix(e),keyId:a,signingFunction:async n=>({keyId:a,addr:y(e),signature:S(o,n.message)})})},x=e=>"object"==typeof e&&null!==e,k=(e,n)=>{const a=e[e.length-1];return e.slice(0,-1).map(e=>n(e,a))},F=(e,n)=>{if(0===e.length)return[];const a=e[0];return Array.isArray(a)&&a[a.length-1].asArgument?(e=>e.reduce((e,n)=>[...e,...k(n,(e,n)=>s.arg(e,n))],[]))(e):o(n,e)},P=e=>async n=>{let a,t,r,s,o,c;if(x(n[0])){const[e]=n,{name:c,code:i,args:l,signers:d,service:g=!1}=e;if(o=g,!c&&!i)throw Error("Both `name` and `code` are missing. Provide either of them");t=c,a=i,r=d,s=l}else"script"===e?[t,s]=n:[t,r,s]=n;if(t){const n="script"===e?xe:Te;a=await n({name:t})}c=o?Me:await he(a);const i=await le(),l=M({},Me,c,{FlowManager:i});return a=we(a,l),{code:a,signers:r,args:s}},E=async(...e)=>{const n=P("tx"),{code:a,args:t,signers:r}=await n(e),o=T(),c=[s.transaction(a),s.payer(o),s.proposer(o),s.limit(999)];if(r){const e=r.map(e=>T(e));c.push(s.authorizations(e))}else c.push(s.authorizations([o]));t&&c.push(s.args(F(t,a)));const i=await s.send(c);return await s.tx(i).onceExecuted()},v=async(...e)=>{const n=P("script"),{code:a,args:t}=await n(e),r=[s.script(a)];t&&r.push(s.args(F(t,a)));const o=await s.send(r);return s.decode(o)},R="\n  import FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n \n",C=async(e={})=>{const n=M({},await c(),e);return i(R,n,"createAccount =>"),l(R,n)},B=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await C(e);return d("arguments",n.length,3,B),d("signers",a.length,1,B),E({code:t,args:n,signers:a})},I="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n",D=async(e={})=>{const n=M({},await c(),e);return i(I,n,"deployContract =>"),l(I,n)},$=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await D(e);return d("arguments",n.length,3,$),d("signers",a.length,1,$),E({code:t,args:n,signers:a})},_='\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: "FlowManager",\n           code: code.decodeHex(),\n        )\n   }\n}\n\n',L=async(e={})=>{const n=M({},await c(),e);return i(_,n,"initManager =>"),l(_,n)},H=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await L(e);return d("arguments",n.length,1,H),d("signers",a.length,1,H),E({code:t,args:n,signers:a})},G='\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic("Signer is not the token admin")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic("Unable to borrow receiver reference")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n',K=async(e={})=>{const n=M({},await c(),e);return i(G,n,"mintTokens =>"),l(G,n)},O=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await K(e);return d("arguments",n.length,2,O),d("signers",a.length,1,O),E({code:t,args:n,signers:a})},V="\n  import FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n",z=async(e={})=>{const n=M({},await c(),e);return i(V,n,"registerContract =>"),l(V,n)},N=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await z(e);return d("arguments",n.length,2,N),d("signers",a.length,1,N),E({code:t,args:n,signers:a})},U="\n  transaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n",j=async(e={})=>{const n=M({},await c(),e);return i(U,n,"scratch =>"),l(U,n)},Y=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await j(e);return d("arguments",n.length,0,Y),d("signers",a.length,1,Y),E({code:t,args:n,signers:a})},W="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",q=async(e={})=>{const n=M({},await c(),e);return i(W,n,"updateContract =>"),l(W,n)},J=async({addressMap:e={},args:n=[],signers:a=[]})=>{const t=await q(e);return d("arguments",n.length,3,J),d("signers",a.length,1,J),E({code:t,args:n,signers:a})};var Q={createAccount:B,createAccountTemplate:C,deployContract:$,deployContractTemplate:D,initManager:H,initManagerTemplate:L,mintTokens:O,mintTokensTemplate:K,registerContract:N,registerContractTemplate:z,scratch:Y,scratchTemplate:j,updateContract:J,updateContractTemplate:q};const{updateContractTemplate:X,deployContractTemplate:Z}=Q,ee=e=>Buffer.from(e,"utf8").toString("hex"),ne=async(...e)=>{const n=await(async e=>{let n,a,t,r,s;if(x(e[0])){const[o]=e,{name:c,to:i,addressMap:l,args:d,update:g}=o;if(!c)throw Error("'name' field is missing");n=c,a=i,r=d,t=l,s=g}else[n,a,t,r,s]=e;const o=await le();return{name:n,to:a,args:r,update:s,addressMap:M({},Me,{FlowManager:o},t)}})(e),{to:a,name:t,addressMap:r,args:s,update:o=!1}=n,c=a||await le(),i=await Se({name:t,addressMap:r});return ae({to:c,code:i,name:t,args:s,update:o})},ae=async e=>{const{to:n,code:a,name:t,args:s,update:o}=e,c=n||await le(),i=await le(),l=ee(a),d={FlowManager:i};let g=o?await X(d):await Z(d),u=[[t,l,r.String],[i,r.Address]];if(s){u=u.concat(s);let e=0;const n=[],a=s.reduce((a,t)=>[...a,...k(t,(a,t)=>{const r="abcdefghijklmnopqrstuvwxyz"[e];return e+=1,n.push(r),`${r}:${t.label}`})],[]);g=g.replace("##ARGS-WITH-TYPES##",`, ${a}`),g=g.replace("##ARGS-LIST##",n)}else g=g.replace("##ARGS-WITH-TYPES##",""),g=g.replace("##ARGS-LIST##","");return E({code:g,args:u,signers:[c]})},te="\n  pub contract FlowManager {\n\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    init(){\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.accountManagerStorage = /storage/testSuitAccountManager\n        self.contractManagerStorage = /storage/testSuitContractManager\n\n        self.accountManagerPath = /public/testSuitAccountManager\n        self.contractManagerPath = /public/testSuitContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n",re="\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty. The script will throw error if FlowManager is not\n    // added to service address\n}\n\n",se="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n",oe='\n  // This script reads the balance field of an account\'s FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic("Could not borrow Balance reference to the Vault")\n\n    return vaultRef.balance\n}\n',ce="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n";var ie=Q;const le=async()=>y(await n().get("SERVICE_ADDRESS")),de=async()=>{const e={FlowManager:await le()},n=await(async(e={})=>{const n=M({},await c(),e);return i(re,n,"checkManager =>"),l(re,n)})(e);try{await v({code:n,service:!0})}catch(e){await(async()=>{const e=await ie.initManagerTemplate(),n=await(async(e={})=>{const n=M({},await c(),e);return i(te,n,"FlowManager =>"),l(te,n)})(),a=[[ee(n),r.String]];await E({code:e,args:a,service:!0})})()}return le()},ge=async(e,n=!1)=>{if(n){const n=Me[e];if(void 0!==n)return n}const a=await de(),t={FlowManager:a};let s;try{const n=await(async(e={})=>{const n=M({},await c(),e);return i(ce,n,"getContractAddress =>"),l(ce,n)})(t),o=[[e,r.String],[a,r.Address]];s=await v({code:n,args:o,service:!0})}catch(e){console.error("failed to get account address:",e)}return s},ue=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,pe=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),me=(e,n)=>{const[a,t]=n;return e[a]=t,e},fe=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(pe).reduce(me,{}):{},we=(e,n,a=!0)=>e.replace(ue,(e,t,r,s,o)=>{const c=a?r:o;return`${t}${r} from ${n instanceof Function?n(c):n[c]}`}),he=async e=>{const n={},a=fe(e);for(const e in a)if(Me[e])n[e]=Me[e];else{const a=await ge(e);n[e]=a}return n},Me={FlowToken:"0x0ae53cb6e3f42a79",FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7"},Ae={"0xe5a8b7f23e8b548f":"0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7":"0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79":"0x0ae53cb6e3f42a79","0xee82856bf20e2aa6":"0xee82856bf20e2aa6"},ye=async(e,a="./transactions/")=>{const r=await n().get("BASE_PATH");return t.resolve(r,`${a}/${e}.cdc`)},be=(e,n={},t=!1)=>{const r=(e=>a.readFileSync(e,"utf8"))(e);return n?we(r,M({},t?Ae:Me,n)):r},Se=async({name:e,addressMap:n})=>{const a=await ye(e,"./contracts/");return be(a,n)},Te=async({name:e,addressMap:n})=>{const a=await ye(e,"./transactions/");return be(a,n)},xe=async({name:e,addressMap:n})=>{const a=await ye(e,"./scripts/");return be(a,n)},ke={ExampleToken:Me.FlowToken},Fe=e=>e[0].toLowerCase()+e.slice(1),Pe=async e=>{const n=await(async e=>(await(async(e={})=>{const n=M({},await c(),e);return i(oe,n,"getBalance =>"),l(oe,n)})(ke)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Fe(e)))("FlowToken"),a=we(n,Me);return v({code:a,args:[[e,r.Address]]})},Ee=async(e,n)=>{const a=await(async e=>(await ie.mintTokensTemplate(ke)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Fe(e)))("FlowToken"),t=we(a,Me);return E({code:t,args:[[e,r.Address],[n,r.UFix64]]})},ve=async e=>{const a=e||`deployment-account-${(Math.random()*Math.pow(10,8)).toFixed(0)}`,t=await de(),s={FlowManager:t};let o;try{const e=await(async(e={})=>{const n=M({},await c(),e);return i(se,n,"getAccountAddress =>"),l(se,n)})(s),n=[[a,r.String],[t,r.Address]];o=await v({code:e,args:n,service:!0})}catch(e){console.error("failed to get account address:",e)}if(null===o)try{const e=await ie.createAccountTemplate(s),c=[[a,await(async()=>{const e=b.keyFromPrivate(Buffer.from(await n().get("PRIVATE_KEY"),"hex")).getPublic("hex").replace(/^04/,"");return p.encode([Buffer.from(e,"hex"),2,3,1e3]).toString("hex")})(),r.String],[t,r.Address]],{events:i}=await E({code:e,args:c});o=i.find(e=>e.type.includes("AccountAdded")).data.address}catch(e){console.error(e)}return o},{expect:Re}=global,Ce=async e=>"function"==typeof e?await e():await e,Be=async e=>{const n=Ce(e);return await Re(n).resolves.not.toBe(null),await Re(n).resolves.not.toThrow(),n.then(({status:e,errorMessage:n})=>{Re(e).toBe(4),Re(n).toBe("")}),n},Ie=async e=>{const n=Ce(e);return await Re(n).resolves.not.toThrow(),n},De=async e=>{const n=Ce(e);await Re(n).rejects.not.toBe(null)},$e=async e=>{const n=Ce(e);await Re(n).rejects.not.toBe(null),await Re(n).rejects.toThrow()},{spawn:_e}=require("child_process");var Le=new class{constructor(){this.initialized=!1,this.logging=!0}setLogging(e){this.logging=e}log(e,n="log"){this.logging&&console[n](e)}async start(e=8080,n=!1){let a=e-8080+3569;return this.logging=n,this.process=_e("flow",["emulator","-v","--http-port",e,"--port",a]),new Promise((e,n)=>{this.process.stdout.on("data",n=>{this.log(`LOG: ${n}`),n.includes("Starting HTTP server")&&(this.log("EMULATOR IS UP! Listening for events!"),this.initialized=!0,e(!0))}),this.process.stderr.on("data",e=>{this.log(`ERROR: ${e}`,"error"),this.initialized=!1,n()}),this.process.on("close",n=>{this.log(`emulator exited with code ${n}`),this.initialized=!1,e(!0)})})}async stop(){return new Promise(e=>{this.process.kill(),setTimeout(()=>{this.initialized=!1,e(!0)},50)})}};export{ae as deployContract,ne as deployContractByName,Le as emulator,v as executeScript,fe as extractImports,ve as getAccountAddress,w as getConfigValue,ge as getContractAddress,Se as getContractCode,Pe as getFlowBalance,xe as getScriptCode,le as getServiceAddress,be as getTemplate,Te as getTransactionCode,h as init,Ee as mintFlow,Ce as promise,we as replaceImportAddresses,he as resolveImports,E as sendTransaction,f as set,Be as shallPass,Ie as shallResolve,De as shallRevert,$e as shallThrow};
//# sourceMappingURL=index.modern.js.map
